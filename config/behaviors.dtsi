#define SIMPLE_MORPH(NAME, MOD, BINDING1, BINDING2) \
    ZMK_MOD_MORPH(NAME, \
        mods = <(MOD_L ## MOD|MOD_R ## MOD)>; \
        bindings = <BINDING1>, <BINDING2>; \
    )

// tap: qmark | shift + tap: excl
SIMPLE_MORPH(qexcl, SFT, &kp QMARK, &kp EXCL)
// Tap: lparens  |  shift + tap: <
SIMPLE_MORPH(lpar_lt, SFT, &kp LPAR, &smrt_brk LESS_THAN)
// Tap: lparens  |  shift + tap: <
SIMPLE_MORPH(rpar_gt, SFT, &kp RPAR, &smrt_brk GREATER_THAN)

// tap: comma | shift + tap: semicolon | ctrl + shift + tap: <
SIMPLE_MORPH(comma_semi, SFT, &kp COMMA, &kp SEMI)

// tap: dot | shift + tap: colon | ctrl + shift + tap: >
SIMPLE_MORPH(dot_colon, SFT, &kp DOT, &kp COLON)

// tap { | shift + tap: [
SIMPLE_MORPH(lbrc, SFT, &kp LBRC, &smrt_brk LBKT)
SIMPLE_MORPH(rbrc, SFT, &kp RBRC, &smrt_brk RBKT)

// tap: sticky-shift | shift + tap/ double-tap: caps-word | hold: shift
ZMK_MOD_MORPH(smart_shft,
    bindings = <&sk LSHFT>, <&caps_word>;
    mods = <(MOD_LSFT)>;
)

// Define "behaviors" for HRM chord
ZMK_BEHAVIOR(tab, tap_dance,
    tapping-term-ms = <0>;
    bindings = <&kp TAB>;
)

ZMK_BEHAVIOR(esc, tap_dance,
    tapping-term-ms = <0>;
    bindings = <&kp ESC>;
)

ZMK_BEHAVIOR(l_than, tap_dance,
    tapping-term-ms = <0>;
    bindings = <&kp LESS_THAN>;
)

ZMK_BEHAVIOR(g_than, tap_dance,
    tapping-term-ms = <0>;
    bindings = <&kp GREATER_THAN>;
)

ZMK_BEHAVIOR(nav, tap_dance,
    tapping-term-ms = <400>;
    bindings = <&mo NAV>, <&mo MV>;
)

// for some reason this seems to be order dependent
ZMK_CONDITIONAL_LAYER(util, NAV NUM, UTIL)
ZMK_CONDITIONAL_LAYER(util, NUM NAV, UTIL)
